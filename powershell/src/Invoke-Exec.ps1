
<#
    .SYNOPSIS
    Execute an external command.

    .DESCRIPTION
    Execute an external command (passed as a string) and determine its
    sucess or failure. On failure throw a terminating error. Otherwise
    return the output generated by the command.

    .EXAMPLE
    Invoke-Exec 'docker build .'

    .EXAMPLE
    Invoke-Exec 'docker-compose.exe' 'exec webserver php vendor/bin/behat' -Verbose

    Write output to the Verbose stream as it occurs, Useful for example when watching a
    long running process.

    .NOTES
    1. The external command is executed in a seperate process to ensure environment isolation.
    2. Standard Error outputs are captured rather than flowing through to the console
    3. If the -Verbose option is used, or $VerbosePreference is set to 'Continue', output
    is echoed to the console as it occurs.

#>
function Invoke-Exec {
    [CmdletBinding()]
    param (
        # The external command (executable or script) to be executed.
        # Can be the name of an executable in the $Path or the full or relative
        # path to an executable file.
        [Parameter(Mandatory, Position = 0)]
        [string]
        [ValidateNotNullOrEmpty()]
        $Command,

        # The arguments to be passed to the command.
        [Parameter(Position = 1)]
        [string]
        [ValidateNotNullOrEmpty()]
        $CommandArgs = '',

        # Environment variables to be set prior to executing the command. These are
        # set in the context of the process.
        [Parameter()]
        [hashtable]
        $EnvVars = @{}
    )

    $proc = [System.Diagnostics.Process]::New()

    $proc.StartInfo.UseShellExecute = $false
    $proc.StartInfo.RedirectStandardError = $true
    $proc.StartInfo.RedirectStandardOutput = $true
    $proc.StartInfo.CreateNoWindow = $true
    $proc.StartInfo.FileName = $Command
    $proc.StartInfo.Arguments = $CommandArgs

    # Set environment variables
    foreach ($var in $EnvVars.GetEnumerator()) {
        $proc.StartInfo.EnvironmentVariables.Add($var.Name, $var.Value)
    }

    [void]$proc.Start()

    # Setup async reads to avoid deadlocks
    # Loop on ReadLineAsync so we can show output to the user if Verbose is set
    $out = while ($line = $proc.StandardOutput.ReadLineAsync().GetAwaiter().GetResult()) {
        # If Verbose is set, emit output to the Berbose stream
        Write-Verbose $Line

        # Collect output
        # [void]$out.Add($line)
        $line
    }

    # Read all error output asynchronously
    $errtask = $proc.StandardError.ReadToEndAsync()

    $proc.WaitForExit()

    # Get the error results
    $err = $errtask.GetAwaiter().GetResult()

    if ($proc.ExitCode) {
        throw $err
    }

    $out
}

