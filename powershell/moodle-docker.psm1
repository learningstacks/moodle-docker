Set-StrictMode -Version 3

. (Join-Path $PSScriptRoot 'src/Get-StackParameters.ps1')
. (Join-Path $PSScriptRoot 'src/Get-ComposeFiles.ps1')

[string]$BASEDIR = Resolve-Path (Join-Path $PSScriptRoot '..' '..')

$VALID_DB = 'pgsql', 'mysql', 'mssql', 'oracle', 'mariadb'
$VALID_PHP_VERSION = '5.6', '7.0', '7.1', '7.2', '7.3', '7.4', '8.0'
$VALID_APP_RUNTIME = 'ionic3', 'ionic5'
$VALID_HOST_PORT = '(?<HOST>\d+\.\d+\.\d+\.\d+:)?(?<PORT>[1-9]\d*)'
$VALID_BROWSER = '^(?<NAME>chrome|firefox)(:(?<TAG>.+))?$'

$BASE_INVOCATION = $null

function GetDockerComposeVersion {
    $verstring = $null
    try {
        $Invocation = @{
            Command     = 'docker'
            CommandArgs = 'compose version'
        }
        $verstring = Invoke-Exec @Invocation
    }
    catch {
        $Invocation = @{
            Command     = 'docker-compose'
            CommandArgs = 'version'
        }
        $verstring = Invoke-Exec @Invocation
    }
    if ($verstring -match '^.* v(?<VERSION>.+)$') {
        return [version]$Matches.VERSION
    }
    else {
        throw "Unable to parse docker compose version from $verstring"
    }
}

function GetBaseInvocation {
    if (-Not $BASE_INVOCATION ) {
        if (GetDockerComposeVersion -ge [version]'2.0') {
            $BASE_INVOCATION = @{
                ComposeExe         = 'docker'
                ComposeCommandArgs = @('compose')
            }
        }
        else {
            $BASE_INVOCATION = @{
                ComposeExe         = 'docker-compose'
                ComposeCommandArgs = @()
            }
        }
    }
    return $BASE_INVOCATION.Clone()
}

<#
    .SYNOPSIS
    Convert all path seperators to unix (/)
    #>
filter NormalizePath {
    $_.ToString() -replace '(/|\\)+', '/'
}

<#
    .SYNOPSIS
    Execute an external command.

    .DESCRIPTION
    Execute an external command (passed as a string) and determine its
    sucess or failure. On failure throw a terminating error. Otherwise
    return the output generated by the command.

    .EXAMPLE
    Invoke-Exec 'docker build .'

    .EXAMPLE
    Invoke-Exec 'docker-compose.exe' 'exec webserver php vendor/bin/behat' -Verbose

    Write output to the Verbose stream as it occurs, Useful for example when watching a
    long running process.

    .NOTES
    1. The external command is executed in a seperate process to ensure environment isolation.
    2. Standard Error outputs are captured rather than flowing through to the console
    3. If the -Verbose option is used, or $VerbosePreference is set to 'Continue', output
    is echoed to the console as it occurs.

#>
function Invoke-Exec {
    [CmdletBinding()]
    param (
        # The external command (executable or script) to be executed.
        # Can be the name of an executable in the $Path or the full or relative
        # path to an executable file.
        [Parameter(Mandatory, Position = 0)]
        [string]
        [ValidateNotNullOrEmpty()]
        $Command,

        # The arguments to be passed to the command.
        [Parameter(Position = 1)]
        [string]
        [ValidateNotNullOrEmpty()]
        $CommandArgs = '',

        # Environment variables to be set prior to executing the command. These are
        # set in the context of the process.
        [Parameter()]
        [hashtable]
        $EnvVars = @{}
    )

    $proc = [System.Diagnostics.Process]::New()

    $proc.StartInfo.UseShellExecute = $false
    $proc.StartInfo.RedirectStandardError = $true
    $proc.StartInfo.RedirectStandardOutput = $true
    $proc.StartInfo.CreateNoWindow = $true
    $proc.StartInfo.FileName = $Command
    $proc.StartInfo.Arguments = $CommandArgs

    # Set environment variables
    foreach ($var in $EnvVars.GetEnumerator()) {
        $proc.StartInfo.EnvironmentVariables.Add($var.Name, $var.Value)
    }

    [void]$proc.Start()

    # Setup async reads to avoid deadlocks
    # Loop on ReadLineAsync so we can show output to the user if Verbose is set
    $out = while ($line = $proc.StandardOutput.ReadLineAsync().GetAwaiter().GetResult()) {
        # If Verbose is set, emit output to the Berbose stream
        Write-Verbose $Line

        # Collect output
        # [void]$out.Add($line)
        $line
    }

    # Read all error output asynchronously
    $errtask = $proc.StandardError.ReadToEndAsync()

    $proc.WaitForExit()

    # Get the error results
    $err = $errtask.GetAwaiter().GetResult()

    if ($proc.ExitCode) {
        throw $err
    }

    $out
}



class Stack {
    [hashtable]$PassedParams
    [hashtable]$StackParams
    [hashtable]$Defaults
    [System.Collections.ArrayList]$ComposeFiles = @()
    [string[]]$ComposeFilePaths = @(
        $PWD
        $BASEDIR
    )

    Stack([hashtable]$StackParams, [string[]]$ComposeFiles) {
        $this.StackParams = $StackParams
        $this.ComposeFiles = $ComposeFiles
    }

    Stack([hashtable]$Params) {
        $ErrorActionPreference = 'Stop'
        $this.PassedParams = $Params.Clone()
        $this.StackParams = Get-StackParams $this.PassedParams
        $this.ComposeFiles = Get-ComposeFiles $this.StackParams $this.ComposeFilePaths
    }

    [boolean] IncludesApp() {
        return ($this.StackParams.MOODLE_DOCKER_APP_PATH -or $this.StackParams.MOODLE_DOCKER_APP_VERSION)
    }

    [void] start() {
        $this.Invoke('up -d')
        $this.WaitDb()
        $this.WaitApp()
        Write-Verbose 'Stack started'
    }

    [Object] Invoke($Command) {
        $Invocation = $this.GetInvocation($Command)
        $result = Invoke-Exec @Invocation
        return $result
    }

    [hashtable] GetInvocation([string]$Command) {
        $files = ($this.ComposeFiles | ForEach-Object { "-f $_" }) -join ' '
        $base = (GetBaseInvocation)
        return @{
            Command     = $base.ComposeExe
            CommandArgs = "$($base.ComposeCommandArgs) $files $Command"
            EnvVars     = $this.StackParams
        }
    }

    [void] WaitDb() {
        $DBType = $this.StackParams.MOODLE_DOCKER_DB

        if (!$DBType) {
            throw 'MOODLE_DOCKER_DB is not set'
        }

        if ($DBType -eq 'mssql') {
            $this.Invoke('exec db /wait-for-mssql-to-come-up.sh')
        }
        elseif ($DBType -eq 'oracle') {
            while (-Not ($this.Invoke('logs db') | Select-String -Pattern 'listening on IP')) {
                Write-Verbose 'Waiting for oracle to come up...'
                Start-Sleep -Seconds 15
            }
        }
        else {
            Start-Sleep 5
        }
    }

    [void] WaitApp() {
        if ($this.IncludesApp()) {
            while (-Not ($this.Invoke('logs moodleapp') | Select-String -Pattern 'dev server running: |Angular Live Development Server is listening|Configuration complete; ready for start up')) {
                Write-Verbose 'Waiting for Moodle app to come up...'
                Start-Sleep -Seconds 15
            }
        }
    }

}

<#
    .SYNOPSIS
    Create a new Stack instance.
#>
function New-Stack {
    param(
        [Parameter(Mandatory)]
        [hashtable]$StackParams
    )

    [Stack]::New($StackParams)
}

function Get-Stack {
    [CmdletBinding()]
    param(
        [Parameter(Position = 0)]
        [System.IO.FileInfo]
        [ValidateScript(
            {
                if (-Not (Test-Path $_ -PathType Leaf)) {
                    Throw "File $_ does not exist"
                }
                $true
            }
        )]
        $Path
    )

    if (-Not $Path) {
        # Look for stack.json or stack.env if current directory or any parent
        $loc = Get-Location
        while ($loc -and !$result) {
            foreach ($target in 'stack.json', 'stack.env') {
                $f = Join-Path $loc $target
                if (Test-Path $f -PathType Leaf) {
                    $Path = $f
                }
            }
            if (!$Path) {
                # Now look in parent dir
                $loc = Split-Path $loc -Parent
            }
        }
    }

    if ($Path) {
        if ($Path.Name -eq 'stack.json') {
            # Import previously exported stack definition
            Import-Stack $Path
        }
        elseif ($Path.Name -eq 'stack.env') {
            # Parse parameters from the file
            $data = Import-Csv $Path -Delimiter '=' -Header Name, Value
            $params = @{}
            foreach ($item in $data) {
                $params[$item.Name] = $item.Value
            }
            New-Stack @params
        }
    }
    else {
        # New-Stack will attempt to set parameters from environment variables and default values
        New-Stack -ErrorAction Stop
    }
}

function Start-Stack {
    [CmdletBinding()]
    param(
        [Parameter(ValueFromPipeline)]
        [Stack]$Stack
    )

    Process {
        if (-Not $Stack) {
            $Stack = Get-Stack -ErrorAction Stop
        }
        $Stack.Start() | Invoke-Stack 'up -d'
    }
}

function Invoke-Stack {
    [CmdletBinding()]
    param(
        [Parameter(ValueFromPipeline)]
        [Stack]$Stack,

        [Parameter(Position = 0)]
        [string]$Command
    )

    Process {
        if (-Not $Stack) {
            $Stack = Get-Stack -ErrorAction Stop
        }
        $Stack.Invoke($Command)
    }
}

function Import-Stack {
    [CmdletBinding()]
    param(
        [string]$Path
    )

    if (-Not $Path) {
        $FileName = 'stack.json'
        $loc = Get-Location
        while (-Not $Path -and $loc) {
            $filepath = Join-Path $loc $FileName
            if (Test-Path $filepath -PatyType Container) {
                $Path = $filepath
            }
            else {
                $loc = Split-Path $loc -Parent
            }
        }
        if (-Not $Path) {
            throw 'Unable to find stack.json in current directory or any parent'
        }
    }

    $props = Get-Content $Path | ConvertFrom-Json

}

function Export-Stack {
    [CmdletBinding()]
    param(
        [string]$Path = (Join-Path $PWD 'stack.json')
    )

    $Hash = @{
        Environment  = $Stack.Environment
        ComposeFiles = $Stack.ComposeFiles
    }

    $Hash | ConvertTo-Json | Out-File -FilePath $Path -Force

}

$exports = @{
    Variable = '*'
    Function = @(
        'New-Stack'
        'Get-Stack'
    )
}

Export-ModuleMember @exports